;<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>
    <script>
        /*
        Prince Arthas needs your help! Mal'ganis has spread an infection amongst the Stratholme citizens, and we must help Arthas prevent this infection from spreading to other parts of the Kingdom.

        You will receive a string s as input: Each "word" represents a house, and each letter represents a citizen. All infected citizens are represented as "i" or "I" in s. 
        You must eradicate them, and their neighbors. If an infected citizen appears after or before a space, you should not delete the space, but keep in mind that the distance 
        from "house" to "house" (word to word) has to have only one whitespace.

        EXAMPLES:

        "STRING"                       -> "STG"
        "1i2 33 i4i5 i555ii5"          -> "33 5"
        "It is a bit chilly"           -> "a cly"
        "Pineapple pizza is delicious" -> "eapple za deus"
        "It is not there"              -> "not there"
        NOTES:

        There are no apostrophes or any non-alphanumeric characters other than whitespaces.
        Make sure there are no leading or trailing spaces in the result string
        You will always be given a valid string.
        You won't be provided any empty strings.
        Good luck and for the Alliance!
        */

        console.log(purifyTheStratholme("It is not there"));

        function purifyTheStratholme(s) {
            let strArr = s.split('');
            
            let breakpoints = [];
            strArr.map((char, index) => {
                if (/[iI]/.test(char)) breakpoints.push(index);
            })

            let addSurroundingBreakpoints = [];
            breakpoints.map((bk) => {
                if (bk !== 0 && bk < strArr.length) {
                    addSurroundingBreakpoints.push(bk - 1);
                    addSurroundingBreakpoints.push(bk);
                    addSurroundingBreakpoints.push(bk + 1);
                } else {
                    if (bk === 0) {
                        addSurroundingBreakpoints.push(bk);
                        addSurroundingBreakpoints.push(bk + 1);
                    }
                    if (bk < strArr.length) {
                        addSurroundingBreakpoints.push(bk - 1);
                        addSurroundingBreakpoints.push(bk);
                    }
                }
            })

            let result = [];
            strArr.map((char, index) => {
                if (!addSurroundingBreakpoints.includes(index)) {
                    result.push(char);
                }
            })

            return result.join("").trim();
        }
    </script>
    <body>
        
    </body>
    </html>
</head>
<body>
    
</body>
</html>